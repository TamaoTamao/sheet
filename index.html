<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D20 character sheet</title>
    <style>
        :root {
            --color-parchment: #f4e8d0;
            --color-parchment-dark: #e6d5b8;
            --color-parchment-darker: #d4c3a5;
            --color-ink: #2c1810;
            --color-ink-light: #4a3428;
            --color-accent-gold: #8b6914;
            --color-accent-red: #8b2e1f;
            --color-border-dark: #5d4a3a;
            --color-success: #4a7c4e;
            --color-warning: #a67c3a;
            --color-danger: #8b2e1f;
            --color-hp-yellow: #c19a3d;
            --color-hp-green: #4a7c4e;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, Georgia, serif;
            background: linear-gradient(135deg, #c9b89a 0%, #e6d5b8 50%, #c9b89a 100%);
            color: var(--color-ink);
            padding: 20px;
            line-height: 1.6;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 600px;
            background-image: url('https://agi-prod-file-upload-public-main-use1.s3.amazonaws.com/e1faea3b-6c21-44a1-a2d1-d016eb553111');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.03;
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        /* --- Unified toggle & lang‑scroll styles --- */
        .toggle-core {
          position: relative;
          display: inline-flex;
          align-items: center;
          justify-content: center;
          padding: 4px;
          gap: 6px;
          transform: scale(0.95);
          user-select: none;
        }

        .toggle-grid.grid-2x2 { display: grid; grid-template-columns: repeat(2, auto); grid-template-rows: repeat(2, auto); gap: 6px; }
        .toggle-row { display:flex; gap:6px; align-items:center; }

        .toggle-core .circle {
          width: 14px;
          height: 14px;
          border-radius: 50%;
          display: inline-flex;
          align-items: center;
          justify-content: center;
          font-size: 0.6rem;
          font-weight: 700;
          color: var(--color-parchment);
          background: var(--color-parchment-darker);
          transition: transform 180ms ease, opacity 180ms ease, background-color 180ms;
          box-shadow: 0 1px 2px rgba(44,24,16,0.18);
          pointer-events: auto;
        }

        /* Ensure mode-toggle circles stay perfectly round and not resized by text/padding */
        .mode-toggle .circle {
          width: 14px !important;
          height: 14px !important;
          min-width: 14px !important;
          min-height: 14px !important;
          padding: 0 !important;
          line-height: 14px !important;
          overflow: hidden !important;
          text-indent: 0 !important;
          display: inline-flex !important;
          align-items: center !important;
          justify-content: center !important;
          box-sizing: border-box !important;
        }

        /* common active/inactive */
        .toggle-core .circle.active {
          transform: scale(1);
          opacity: 1;
          background: var(--color-accent-gold);
          color: var(--color-parchment);
        }
        .toggle-core .circle.inactive {
          transform: scale(0.5);
          opacity: 0.5;
          background: var(--color-parchment-darker);
          color: var(--color-parchment);
        }

        /* mode-specific colors: read = red, edit = green (user request) */
        .mode-toggle .circle[data-mode="read"].active { background: var(--color-accent-red); color: var(--color-parchment); }
        .mode-toggle .circle[data-mode="edit"].active { background: var(--color-hp-green); color: var(--color-parchment); }
        /* mode-toggle inactive border (black) */
        .mode-toggle .circle.inactive { border: 1px solid rgba(0,0,0,0.9); box-shadow: 0 1px 2px rgba(44,24,16,0.18), inset 0 0 0 1px rgba(0,0,0,0.03); }

        .toggle-core .lens {
          position: absolute;
          width: 18px;
          height: 18px;
          border-radius: 50%;
          border: 2px solid rgba(44,24,16,0.95);
          background: transparent;
          pointer-events: none;
          box-shadow: 0 1px 0 var(--color-parchment);
          transition: left 180ms ease, top 180ms ease;
          z-index: 10;
        }

        /* lang-scroll SVG specific */
        .lang-scroll { cursor: pointer; display:inline-block; line-height:0; }
        .scroll-icon { width: 48px; height: 68px; display:block; }
        .lang-circle { transition: fill 220ms ease, stroke 220ms ease, transform 220ms ease; }
        .lang-circle.active { fill: #fff; stroke: rgba(0,0,0,0.85); transform: scale(1.05); }
        .lang-circle.inactive { fill: var(--color-parchment-darker); stroke: rgba(0,0,0,0.9); transform: scale(0.6); }
        .lang-text { transition: opacity 220ms ease, transform 220ms ease; pointer-events: none; }
        .lang-text.active { fill: var(--color-ink); opacity: 1; transform: translateY(0); font-weight:800; }
        .lang-text.inactive { fill: var(--color-parchment); opacity: 0.9; transform: translateY(0); }
        .lang-shift-out { opacity: 0; transform: translateY(6px) scale(0.9); }
        .lang-shift-in  { opacity: 1; transform: translateY(0) scale(1); }

        /* inline tooltip (used by JS) */
        .inline-tooltip {
          position: absolute;
          bottom: -40px;
          right: 0;
          background: rgba(244,232,208,0.95);
          color: var(--color-ink);
          padding: 6px 10px;
          border-radius: 6px;
          box-shadow: 0 4px 12px rgba(44,24,16,0.18);
          font-size: 0.85rem;
          z-index: 50;
          white-space: nowrap;
        }

        /* center toast */
        .center-toast {
          position: fixed;
          left: 50%;
          top: 50%;
          transform: translate(-50%, -50%) scale(0.98);
          background: rgba(244,232,208,0.95);
          color: var(--color-ink);
          padding: 12px 16px;
          border-radius: 8px;
          box-shadow: 0 10px 30px rgba(44,24,16,0.25);
          font-weight: 700;
          z-index: 9999;
          opacity: 0;
          transition: opacity 200ms, transform 200ms;
        }
        .center-toast.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }

        /* top-right placement: anchor to top of document (not fixed) so it scrolls away */
        .top-right-controls {
          position: absolute; /* change from fixed -> absolute so it scrolls off the page */
          top: 14px;
          right: 14px;
          display: flex;
          align-items: center;
          gap: 10px;
          z-index: 9999;
          pointer-events: auto;
        }

        /* hide delete micro buttons in read mode */
        .readonly .btn-danger.btn-micro { display: none !important; }

        /* health bar thumb: rectangular grabber */
        .progress-bar {
            width: 100%;
            height: 12px;
            background: var(--color-parchment-darker);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.4);
        }
        .progress-fill {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 100%;
            transition: width 0.08s linear, background-color 0.08s linear;
            border-radius: 4px;
            z-index: 1;
        }
        /* rectangular grabber (hp thumb) - height computed dynamically, default fallback */
        .hp-thumb {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 28px;
            height: 18px; /* will be overridden by JS to be 120% of bar height */
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(44,24,16,0.25);
            z-index: 2;
            transition: left 0.06s linear, background-color 0.08s linear;
            pointer-events: all;
            touch-action: none;
            display: block;
            background: var(--color-hp-green);
        }

        /* minimal-content inputs: shrink to fit content */
        .compact-min {
          min-width: 1ch;
          width: auto;
          display: inline-block;
        }

        /* bonus input visual offset to the right */
        .item-bonus {
          margin-left: 10px;
          min-width: 2ch;
        }

        /* safety: make room on small screens for controls */
        @media (max-width: 640px) {
          .scroll-icon { width: 40px; height: 56px; }
          .top-right-controls { top: 10px; right: 8px; gap: 8px; }
          h1 { margin-top: 56px; }
        }

        /* rest of original styles (kept) */
        .compact-input {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .compact-input label {
            flex: 0 0 auto;
            min-width: 120px;
        }

        .compact-input input {
            width: 80px;
            padding: 6px 8px;
        }

        .inline-input {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .inline-input label {
            flex: 0 0 auto;
        }

        .inline-input input[type="number"] {
            width: 70px;
            padding: 6px 8px;
        }

        .inline-input input[type="text"] {
            width: 120px;
            padding: 6px 8px;
        }

        h1 {
            color: #fff;
            margin-bottom: 12px;
            font-size: 1.4rem;
            font-weight: bold;
            text-align: center;
            text-shadow:
                0 3px 6px rgba(74, 52, 40, 0.8),
                0 6px 12px rgba(74, 52, 40, 0.7),
                0 9px 18px rgba(74, 52, 40, 0.6),
                0 12px 24px rgba(74, 52, 40, 0.5),
                0 15px 30px rgba(74, 52, 40, 0.4),
                1px 1px 3px rgba(44, 24, 16, 0.9),
                -1px -1px 3px rgba(44, 24, 16, 0.9),
                2px 2px 6px rgba(44, 24, 16, 0.8),
                -2px -2px 6px rgba(44, 24, 16, 0.8);
            letter-spacing: 1px;
            font-variant: small-caps;
        }

        h2 {
            color: #fff;
            margin: 20px 0 12px;
            font-size: 1.4rem;
            border-bottom: 3px double var(--color-accent-gold);
            padding-bottom: 8px;
            font-weight: bold;
            font-variant: small-caps;
            letter-spacing: 1px;
            text-shadow:
                0 2px 5px rgba(74, 52, 40, 0.8),
                0 4px 10px rgba(74, 52, 40, 0.7),
                0 6px 15px rgba(74, 52, 40, 0.6),
                0 8px 20px rgba(74, 52, 40, 0.5),
                1px 1px 2px rgba(44, 24, 16, 0.9),
                -1px -1px 2px rgba(44, 24, 16, 0.9);
        }

        .section {
            background: var(--color-parchment);
            padding: 20px;
            border-radius: 4px;
            margin-bottom: 20px;
            box-shadow:
                0 4px 8px rgba(44, 24, 16, 0.15),
                inset 0 0 30px rgba(212, 195, 165, 0.3);
            position: relative;
        }

        .section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                url('https://agi-prod-file-upload-public-main-use1.s3.amazonaws.com/fee152f2-a72d-40e3-8a44-742260cdc187');
            background-size: 400px;
            background-repeat: repeat;
            opacity: 0.15;
            pointer-events: none;
            border-radius: 4px;
        }

        .section::after {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-width: 0.1px;
            border-color: #fff;
            border-style: solid;
            border-radius: 4px;
            pointer-events: none;
        }

        .grid {
            display: grid;
            gap: 12px;
        }

        .grid-2 {
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        }

        .grid-3 {
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        label {
            font-size: 0.875rem;
            font-weight: 600;
            color: #fff;
            text-shadow:
                0 1px 3px rgba(74, 52, 40, 0.8),
                0 2px 6px rgba(74, 52, 40, 0.7),
                0 3px 9px rgba(74, 52, 40, 0.6),
                0 4px 12px rgba(74, 52, 40, 0.5),
                1px 1px 2px rgba(44, 24, 16, 0.9),
                -1px -1px 2px rgba(44, 24, 16, 0.9);
        }

        input, textarea, select {
            padding: 10px 12px;
            background: var(--color-parchment-dark);
            border: none;
            border-radius: 0;
            color: var(--color-ink);
            font-size: 1rem;
            transition: all 0.2s;
            font-family: inherit;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--color-accent-gold);
            background: var(--color-parchment);
            box-shadow: 0 0 8px rgba(139, 105, 20, 0.3);
        }

        textarea {
            resize: none;
            min-height: 80px;
            font-family: inherit;
            width: 100%;
            box-sizing: border-box;
        }

        /* make notes full width visually (stretches within the section) */
        #notes { width: 100%; box-sizing: border-box; }

        .item-details {
            font-size: 0.85rem;
            color: var(--color-ink-light);
            font-style: italic;
        }
        
        .item-details input,
        .item-details textarea {
            font-family: inherit;
            font-style: inherit;
            font-size: inherit;
            max-width: 100%;
            box-sizing: border-box;
        }

        .stat-compact {
            background: var(--color-parchment-dark);
            padding: 12px;
            border-radius: 50%;
            text-align: center;
            box-shadow:
                inset 0 2px 4px rgba(44, 24, 16, 0.1),
                0 4px 8px rgba(44, 24, 16, 0.2);
            position: relative;
            width: 90px;
            height: 90px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .stat-compact::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('https://agi-prod-file-upload-public-main-use1.s3.amazonaws.com/fee152f2-a72d-40e3-8a44-742260cdc187');
            background-size: 200px;
            opacity: 0.1;
            pointer-events: none;
            border-radius: 50%;
        }

        .stat-compact label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.7rem;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        .stat-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
        }

        .stat-value {
            width: 45px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            padding: 4px;
            background: transparent;
            border: none;
            -webkit-appearance: none;
            -moz-appearance: textfield;
        }

        .stat-value::-webkit-inner-spin-button,
        .stat-value::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .stat-mod {
            width: 40px;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 600;
            padding: 4px;
            background: var(--color-parchment-darker);
            color: var(--color-accent-red);
            border-radius: 12px;
        }

        .btn {
            padding: 10px 20px;
            background: var(--color-accent-gold);
            color: var(--color-parchment);
            border: none;
            border-radius: 3px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        .btn:hover {
            background: var(--color-ink-light);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(44, 24, 16, 0.3);
        }

        .btn-secondary {
            background: var(--color-parchment-darker);
            color: var(--color-ink);
            text-shadow: none;
        }

        .btn-secondary:hover {
            background: var(--color-parchment-dark);
        }

        .btn-danger {
            background: var(--color-danger);
            color: var(--color-parchment);
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 0.875rem;
        }

        .btn-micro {
            width: 1rem;
            height: 1rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            border-radius: 0.2rem;
            font-size: 0.8rem;
        }


        .item {
            background: var(--color-parchment-dark);
            padding: 12px;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 8px;
            box-sizing: border-box;
        }

        .item-info {
            flex: 1 1 auto;
            min-width: 0;
        }

        .item-name {
            font-weight: 700;
            color: #fff;
            text-shadow:
                0 1px 3px rgba(74, 52, 40, 0.8),
                0 2px 6px rgba(74, 52, 40, 0.7),
                0 3px 9px rgba(74, 52, 40, 0.6),
                0 4px 12px rgba(74, 52, 40, 0.5),
                1px 1px 2px rgba(44, 24, 16, 0.9),
                -1px -1px 2px rgba(44, 24, 16, 0.9);
        }

        .item-details {
            font-size: 0.875rem;
            color: var(--color-ink-light);
            margin-top: 4px;
            font-style: italic;
            word-wrap: break-word;
            overflow-wrap: anywhere;
        }

        .item-details textarea {
            max-width: 100%;
            box-sizing: border-box;
        }

        .item-actions {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-shrink: 0;
        }

        .counter {
            display: flex;
            align-items: center;
            gap: 8px;
            background: var(--color-parchment);
            padding: 4px 8px;
            border-radius: 3px;
        }

        .counter button {
            width: 28px;
            height: 28px;
            background: var(--color-accent-gold);
            color: var(--color-parchment);
            border: none;
            border-radius: 2px;
            cursor: pointer;
            font-size: 1.25rem;
            line-height: 1;
            transition: all 0.2s;
            font-weight: bold;
        }

        .counter button:hover {
            background: var(--color-ink-light);
        }

        .counter span {
            min-width: 40px;
            text-align: center;
            font-weight: 600;
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab {
            padding: 10px 20px;
            background: var(--color-parchment-darker);
            color: var(--color-ink-light);
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.2s;
            font-family: inherit;
            font-variant: small-caps;
        }

        .tab.active {
            background: var(--color-accent-gold);
            color: var(--color-parchment);
            border-color: var(--color-ink);
            box-shadow: inset 0 2px 4px rgba(44, 24, 16, 0.3);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .add-form {
            background: var(--color-parchment-darker);
            padding: 16px;
            border-radius: 3px;
            margin-bottom: 16px;
        }

        .form-row {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .form-row > * {
            flex: 1;
            min-width: 200px;
        }

        .health-bar {
            margin-top: 12px;
        }

        .health-display {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 1.125rem;
            font-weight: 600;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--color-ink-light);
            font-style: italic;
        }

        @media (max-width: 768px) {
            .grid-2, .grid-3 {
                grid-template-columns: 1fr;
            }

            .stat-box input {
                font-size: 1.25rem;
            }
        }
    </style>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>

<div class="top-right-controls">
  <!-- Scroll / language SVG (встроенный, без внешних ссылок) -->
  <div class="scroll-container lang-scroll" id="langScrollToggle" role="button" tabindex="0" aria-label="Language toggle" data-selected="ru">
    <svg class="scroll-icon" viewBox="0 0 110 140" aria-hidden="false">
      <defs>
        <mask id="cutout-mask">
          <rect width="100" height="140" fill="white"/>
          <circle cx="50" cy="38" r="9" fill="black"/>
          <circle cx="30" cy="105" r="9" fill="black"/>
          <circle cx="70" cy="105" r="9" fill="black"/>
          <circle cx="50" cy="82" r="12" fill="black"/>
        </mask>
      </defs>

      <!-- Контур свитка -->
      <g transform="rotate(2 50 70)">
        <path d="
            M 16 18
            C 12 42 22 58 16 70
            C 12 82 22 98 16 122
            L 84 122
            C 88 98 78 82 84 70
            C 88 58 78 42 84 18
            Z"
              fill="none" stroke="#000" stroke-width="3" stroke-linejoin="round"/>
      </g>

      <rect x="8" y="12" width="84" height="12" fill="#000" rx="2"/>
      <rect x="8" y="116" width="84" height="12" fill="#000" rx="2"/>

      <g fill="none" stroke="#000" stroke-width="3">
        <circle cx="8" cy="18" r="8"/>
        <circle cx="92" cy="18" r="8"/>
        <circle cx="8" cy="122" r="8"/>
        <circle cx="92" cy="122" r="8"/>
      </g>

      <!-- Буква A с маской (круги вырезают отверстия) -->
      <g mask="url(#cutout-mask)">
        <g stroke="#000" stroke-linecap="round" stroke-linejoin="round" fill="none">
          <path d="M 28 105 Q 42 68 50 38" stroke-width="6.5"/>
          <path d="M 72 105 Q 58 68 50 38" stroke-width="6.5"/>
          <path d="M 28 85 L 72 85" stroke-width="6.5"/>
        </g>
        <g stroke="#000" stroke-linecap="round" stroke-linejoin="round" fill="none">
          <path d="M 28 105 Q 42 72 50 48" stroke-width="8"/>
          <path d="M 72 105 Q 58 72 50 48" stroke-width="8"/>
          <path d="M 34 85 L 66 85" stroke-width="9"/>
        </g>
      </g>

      <!-- рамки кружков внутри A -->
      <g fill="none" stroke="#000" stroke-width="2.5">
        <circle cx="50" cy="38" r="8"/>
        <circle cx="30" cy="105" r="8"/>
        <circle cx="70" cy="105" r="8"/>
        <circle cx="50" cy="82" r="12"/>
      </g>

      <!-- метки языков (положение совпадает с кружками) -->
      <g font-family="Palatino, Georgia, serif" font-weight="700" text-anchor="middle" dominant-baseline="middle">
        <!-- top -->
        <text id="langTextPosTop" class="lang-text" x="50" y="38" font-size="8">FR</text>
        <!-- center: doubled size and moved 1 unit lower -->
        <text id="langTextPosCenter" class="lang-text" x="50" y="83" font-size="16">RU</text>
        <!-- left -->
        <text id="langTextPosLeft" class="lang-text" x="30" y="105" font-size="8">EN</text>
        <!-- right -->
        <text id="langTextPosRight" class="lang-text" x="70" y="105" font-size="8">ES</text>
      </g>
    </svg>
  </div>

  <!-- Mode selector: read (data-mode="read") и edit (data-mode="edit") -->
  <div class="toggle-core mode-toggle" id="modeToggle" role="button" tabindex="0" aria-label="Mode toggle" data-state="edit">
    <div class="toggle-row" aria-hidden="true">
      <div class="circle" data-mode="read" aria-label="Режим чтения"></div>
      <div class="circle" data-mode="edit" aria-label="Режим редактирования"></div>
    </div>
    <div class="lens" aria-hidden="true"></div>
  </div>
</div>

        <h1>D20 лист персонажа</h1>

        <div class="tabs">
            <button class="tab active" data-tab="character">Персонаж</button>
            <button class="tab" data-tab="skills">Навыки</button>
            <button class="tab" data-tab="spells">Заклинания</button>
            <button class="tab" data-tab="inventory">Инвентарь</button>
        </div>

        <div id="character" class="tab-content active">
            <div class="section">
                <h2>Основная информация</h2>
                <div class="input-group" style="margin-bottom: 12px;">
                    <label for="charName">Имя персонажа</label>
                    <input type="text" id="charName" placeholder="Введите имя">
                </div>
                <div class="input-group" style="margin-bottom: 12px;">
                    <label for="charRace">Раса</label>
                    <input type="text" id="charRace" placeholder="Человек, эльф, дворф...">
                </div>
                <div style="display: flex; gap: 12px; align-items: flex-end; margin-bottom: 12px;">
                    <div class="input-group" style="flex: 1;">
                        <label for="charClass">Класс</label>
                        <input type="text" id="charClass" placeholder="Воин, бард, чародей...">
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Характеристики</h2>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; max-width: 700px; margin: 0 auto;">
                    <div class="stat-compact">
                        <label>СИЛ</label>
                        <div class="stat-row">
                            <input type="number" id="statStr" value="10" min="1" max="30" class="stat-value">
                            <input type="text" id="modStr" value="+0" class="stat-mod" readonly>
                        </div>
                    </div>
                    <div class="stat-compact">
                        <label>ЛВК</label>
                        <div class="stat-row">
                            <input type="number" id="statDex" value="10" min="1" max="30" class="stat-value">
                            <input type="text" id="modDex" value="+0" class="stat-mod" readonly>
                        </div>
                    </div>
                    <div class="stat-compact">
                        <label>ТЕЛ</label>
                        <div class="stat-row">
                            <input type="number" id="statCon" value="10" min="1" max="30" class="stat-value">
                            <input type="text" id="modCon" value="+0" class="stat-mod" readonly>
                        </div>
                    </div>
                    <div class="stat-compact">
                        <label>ИНТ</label>
                        <div class="stat-row">
                            <input type="number" id="statInt" value="10" min="1" max="30" class="stat-value">
                            <input type="text" id="modInt" value="+0" class="stat-mod" readonly>
                        </div>
                    </div>
                    <div class="stat-compact">
                        <label>МДР</label>
                        <div class="stat-row">
                            <input type="number" id="statWis" value="10" min="1" max="30" class="stat-value">
                            <input type="text" id="modWis" value="+0" class="stat-mod" readonly>
                        </div>
                    </div>
                    <div class="stat-compact">
                        <label>ХАР</label>
                        <div class="stat-row">
                            <input type="number" id="statCha" value="10" min="1" max="30" class="stat-value">
                            <input type="text" id="modCha" value="+0" class="stat-mod" readonly>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Здоровье и ресурсы</h2>
                <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 12px;">
                    <label for="currentHP" style="white-space: nowrap;">Текущее HP</label>
                    <!-- user requested: keep this editable in read mode, and type text with digits-only -->
                    <input type="text" id="currentHP" value="20" inputmode="numeric" class="compact-min" placeholder="0" style="width: 80px;">
                    <label for="maxHP" style="white-space: nowrap;">Максимальное HP</label>
                    <!-- changed to text + digits-only -->
                    <input type="text" id="maxHP" value="20" inputmode="numeric" class="compact-min" placeholder="0" style="width: 80px;">
                </div>
                <div class="health-bar" style="margin-bottom: 16px;">
                    <div class="progress-bar" id="hpBarContainer">
                        <div class="progress-fill" id="hpBar" style="width:100%"></div>
                        <div class="hp-thumb" id="hpThumb" role="slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100" tabindex="0"></div>
                    </div>
                </div>
                <div class="health-display" style="align-items:center;">
                    <div>
                        <label for="armorClass" style="white-space: nowrap;">Класс доспеха</label>
                        <!-- changed to text + digits-only -->
                        <input type="text" id="armorClass" value="10" inputmode="numeric" class="compact-min" placeholder="0" style="width: 80px;">
                    </div>
                    <div>
                        <label for="speed" style="white-space: nowrap;">Скорость</label>
                        <!-- changed to text + digits-only -->
                        <input type="text" id="speed" value="30" inputmode="numeric" class="compact-min" placeholder="0" style="width: 80px;">
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Заметки</h2>
                <textarea id="notes" placeholder="Заметки о персонаже, история, особенности..."></textarea>
            </div>

            <div class="section">
                <button class="btn" id="saveBtn">Сохранить персо��ажа</button>
                <button class="btn btn-secondary" id="loadBtn" style="margin-left: 12px;">Загрузить персонажа</button>
            </div>
        </div>

        <div id="skills" class="tab-content">
            <div class="section">
                <h2>Навыки</h2>
                <div id="skillsList"></div>
                <div id="skillsAdd" style="margin-top:12px;">
                    <input type="text" id="newSkillName" placeholder="Добавить навык">
                    <div id="skillsExtraFields" style="display:none; margin-top:8px;">
                        <!-- bonus must be text but allow signs and digits -->
                        <input type="text" id="newSkillBonus" placeholder="бонус +0" class="compact-min">
                        <button class="btn btn-small" id="addSkillBtn">Добавить</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="spells" class="tab-content">
            <div class="section">
                <h2>Заклинания</h2>
                <div id="spellsList"></div>
                <div id="spellsAdd" style="margin-top:12px;">
                    <input type="text" id="newSpellName" placeholder="Добавить заклинание">
                    <div id="spellsExtraFields" style="display:none; margin-top:8px;">
                        <div class="form-row">
                            <div class="inline-input">
                                <!-- spell level and slots must be text but only digits -->
                                <input type="text" id="newSpellLevel" placeholder="Уровень заклинания" inputmode="numeric" class="compact-min">
                            </div>
                            <div class="inline-input">
                                <input type="text" id="newSpellSlots" placeholder="Доступные слоты" inputmode="numeric" class="compact-min">
                            </div>
                        </div>
                        <div class="input-group">
                            <textarea id="newSpellDesc" placeholder="Эффект заклинания" style="min-height:60px;"></textarea>
                        </div>
                        <button class="btn btn-small" id="addSpellBtn">Добавить</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="inventory" class="tab-content">
            <div class="section">
                <h2>Инвентарь</h2>
                <div id="inventoryList"></div>
                <div id="itemsAdd" style="margin-top: 16px;">
                    <input type="text" id="ItemName" placeholder="Добавить предмет">
                    <div id="itemsExtraFields" style="display:none; margin-top: 8px;">
                        <div class="form-row">
                            <div class="inline-input">
                                <!-- quantity must be text digits-only -->
                                <input type="text" id="ItemQuantity" placeholder="Количество" inputmode="numeric" class="compact-min">
                            </div>
                            <div class="inline-input">
                                <!-- price must be text (no digits-only restriction) -->
                                <input type="text" id="ItemPrice" placeholder="Рыночная стоимость">
                            </div>
                        </div>
                        <div class="input-group">
                            <textarea id="ItemDesc" placeholder="Свойства" style="min-height:60px;"></textarea>
                        </div>
                        <button class="btn btn-small" id="addItemBtn">Добавить</button>
                    </div>
                </div>
                <div style="margin-top: 20px; padding-top: 16px; border-top: 2px solid var(--color-parchment-darker);">
                    <div class="compact-input">
                        <label for="pp">Платиновые</label>
                        <!-- coins must be text digits-only -->
                        <input type="text" id="pp" value="0" inputmode="numeric" class="compact-min">
                    </div>
                    <div class="compact-input">
                        <label for="gp">Золотые</label>
                        <input type="text" id="gp" value="0" inputmode="numeric" class="compact-min">
                    </div>
                    <div class="compact-input">
                        <label for="sp">Серебряные</label>
                        <input type="text" id="sp" value="0" inputmode="numeric" class="compact-min">
                    </div>
                    <div class="compact-input">
                        <label for="cp">Медные</label>
                        <input type="text" id="cp" value="0" inputmode="numeric" class="compact-min">
                    </div>
                    <div class="compact-input">
                        <label for="inventoryTotal">Общая стоимость инвентаря</label>
                        <input type="text" id="inventoryTotal" placeholder="0 зм. пока что" readonly style="background: var(--color-parchment-darker);">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // --------------------
    // TRANSLATIONS (extended with tooltip/toast keys)
    // --------------------
const translations = {
    en: {
        title: 'D20 Character Sheet',
        tabCharacter: 'Character',
        tabSkills: 'Skills',
        tabSpells: 'Spells',
        tabInventory: 'Inventory',
        basicInfo: 'Basic Information',
        charName: 'Character Name',
        charNamePlaceholder: 'Enter name',
        charClass: 'Class',
        charClassPlaceholder: 'Warrior, mage, rogue...',
        charRace: 'Race',
        charRacePlaceholder: 'Human, elf, dwarf...',
        stats: 'Ability Scores',
        statStr: 'STR',
        statDex: 'DEX',
        statCon: 'CON',
        statInt: 'INT',
        statWis: 'WIS',
        statCha: 'CHA',
        health: 'Health and Resources',
        currentHP: 'Current HP',
        maxHP: 'Max HP',
        armorClass: 'Armor Class',
        speed: 'Speed',
        notes: 'Notes',
        notesPlaceholder: 'Character notes, background, traits...',
        saveBtn: 'Save Character',
        loadBtn: 'Load Character',
        skills: 'Skills',
        skillName: 'Skill Name',
        skillNamePlaceholder: 'New skill',
        skillBonus: 'Bonus',
        skillBonusPlaceholder: '+5 bonus',
        addSkill: 'Add Skill',
        spells: 'Spells',
        spellName: 'Spell Name',
        spellNamePlaceholder: 'New spell',
        spellLevel: 'Level',
        spellSlots: 'Slots (total)',
        spellDesc: 'Description',
        spellDescPlaceholder: 'Effect',
        addSpell: 'Add Spell',
        inventory: 'Inventory',
        coinsPP: 'Platinum',
        coinsGP: 'Gold',
        coinsSP: 'Silver',
        coinsCP: 'Copper',
        totalValue: 'Total Value',
        itemName: 'Item Name',
        itemNamePlaceholder: 'New item',
        itemQuantity: 'Quantity',
        itemPrice: 'Market Price',
        itemPricePlaceholder: 'some gp',
        itemDesc: 'Description',
        itemDescPlaceholder: 'Properties',
        addItem: 'Add Item',
        noSkills: 'No skills added',
        noSpells: 'No spells added',
        noItems: 'Inventory empty',
        savedMsg: 'Character encoded and copied to clipboard!',
        loadedMsg: 'Character loaded!',
        errorMsg: 'Decoding error. Check the input string.',
        loadPrompt: 'Paste encoded character data:',
        // new keys for toggles
        modeReadLabel: 'Read mode',
        modeEditLabel: 'Edit mode',
        toastModeRead: 'Read mode',
        toastModeEdit: 'Edit mode',
        langSelectedPrefix: 'Selected language: ',
        langToastPrefix: 'Language: '
    },
    ru: {
        title: 'D20 лист персонажа',
        tabCharacter: 'Персонаж',
        tabSkills: 'Навыки',
        tabSpells: 'Заклинания',
        tabInventory: 'Инвентарь',
        basicInfo: 'Основная информация',
        charName: 'Имя персонажа',
        charNamePlaceholder: 'Введите имя',
        charClass: 'Класс',
        charClassPlaceholder: 'Воин, маг, вор...',
        charRace: 'Раса',
        charRacePlaceholder: 'Человек, эльф, дворф...',
        stats: 'Характеристики',
        statStr: 'СИЛ',
        statDex: 'ЛВК',
        statCon: 'ТЕЛ',
        statInt: 'ИНТ',
        statWis: 'МДР',
        statCha: 'ХАР',
        health: 'Здоровье и ресурсы',
        currentHP: 'Текущее HP',
        maxHP: 'Максимальное HP',
        armorClass: 'Класс доспеха',
        speed: 'Скорость',
        notes: 'Заметки',
        notesPlaceholder: 'Заметки о персонаже, история, особенности...',
        saveBtn: 'Сохранить персонажа',
        loadBtn: 'Загрузить персонажа',
        skills: 'Навыки',
        skillName: 'Название навыка',
        skillNamePlaceholder: 'Добавить навык',
        skillBonus: 'Бонус',
        skillBonusPlaceholder: '+5 бонус',
        addSkill: 'Добавить навык',
        spells: 'Заклинания',
        spellName: 'Название заклинания',
        spellNamePlaceholder: 'Добавить заклинание',
        spellLevel: 'Уровень',
        spellSlots: 'Слоты (всего)',
        spellDesc: 'Описание',
        spellDescPlaceholder: 'Эффект заклинания',
        addSpell: 'Добавить заклинание',
        inventory: 'Инвентарь',
        coinsPP: 'Платиновые',
        coinsGP: 'Золотые',
        coinsSP: 'Серебряные',
        coinsCP: 'Медные',
        totalValue: 'Общая стоимость инвентаря',
        itemName: 'Название предмета',
        itemNamePlaceholder: 'Добавить предмет',
        itemQuantity: 'Количество',
        itemPrice: 'Рыночная стоимость',
        itemPricePlaceholder: 'несколько зм',
        itemDesc: 'Описание',
        itemDescPlaceholder: 'Свойства предмета',
        addItem: 'Добавить предмет',
        noSkills: 'Навыки не добавлены',
        noSpells: 'Заклинания не добавлены',
        noItems: 'Инвентарь пуст',
        savedMsg: 'Персонаж закодирован и скопирован в буфер обмена!',
        loadedMsg: 'Персонаж загружен!',
        errorMsg: 'Ошибка декодирования данных. Проверьте правильность введенной строки.',
        loadPrompt: 'Вставьте закодированные данные персонажа:',
        // new keys
        modeReadLabel: 'Режим чтения',
        modeEditLabel: 'Режим редактирования',
        toastModeRead: 'Режим чтения',
        toastModeEdit: 'Режим редактирования',
        langSelectedPrefix: 'Выбран язык: ',
        langToastPrefix: 'Язык: '
    },
    fr: {
        title: 'D20 Feuille de Personnage',
        tabCharacter: 'Personnage',
        tabSkills: 'Compétences',
        tabSpells: 'Sorts',
        tabInventory: 'Inventaire',
        basicInfo: 'Informations de Base',
        charName: 'Nom du Personnage',
        charNamePlaceholder: 'Entrez le nom',
        charClass: 'Classe',
        charClassPlaceholder: 'Guerrier, mage, voleur...',
        charRace: 'Race',
        charRacePlaceholder: 'Humain, elfe, nain...',
        stats: 'Caractéristiques',
        statStr: 'FOR',
        statDex: 'DEX',
        statCon: 'CON',
        statInt: 'INT',
        statWis: 'SAG',
        statCha: 'CHA',
        health: 'Santé et Ressources',
        currentHP: 'PV Actuels',
        maxHP: 'PV Maximum',
        armorClass: 'Classe d\'Armure',
        speed: 'Vitesse',
        notes: 'Notes',
        notesPlaceholder: 'Notes sur le personnage, histoire, particularités...',
        saveBtn: 'Sauvegarder',
        loadBtn: 'Charger',
        skills: 'Compétences',
        skillName: 'Nom de la Compétence',
        skillNamePlaceholder: 'Nouvelle compétence',
        skillBonus: 'Bonus',
        skillBonusPlaceholder: '+5 bonus',
        addSkill: 'Ajouter Compétence',
        spells: 'Sorts',
        spellName: 'Nom du Sort',
        spellNamePlaceholder: 'Nouveau sort',
        spellLevel: 'Niveau',
        spellSlots: 'Emplacements (total)',
        spellDesc: 'Description',
        spellDescPlaceholder: 'Effet du sort',
        addSpell: 'Ajouter Sort',
        inventory: 'Inventaire',
        coinsPP: 'Platine',
        coinsGP: 'Or',
        coinsSP: 'Argent',
        coinsCP: 'Cuivre',
        totalValue: 'Valeur Totale',
        itemName: 'Nom de l\'Objet',
        itemNamePlaceholder: 'Nouvel objet',
        itemQuantity: 'Quantité',
        itemPrice: 'Prix du Marché',
        itemPricePlaceholder: 'plusieurs ors',
        itemDesc: 'Description',
        itemDescPlaceholder: 'Propriétés de l\'objet...',
        addItem: 'Ajouter Objet',
        noSkills: 'Aucune compétence ajoutée',
        noSpells: 'Aucun sort ajouté',
        noItems: 'Inventaire vide',
        savedMsg: 'Personnage encodé et copié dans le presse-papier!',
        loadedMsg: 'Personnage chargé!',
        errorMsg: 'Erreur de décodage. Vérifiez la chaîne.',
        loadPrompt: 'Collez les données encodées du персонажа:',
        // new keys
        modeReadLabel: 'Mode lecture',
        modeEditLabel: 'Mode édition',
        toastModeRead: 'Mode lecture',
        toastModeEdit: 'Mode édition',
        langSelectedPrefix: 'Langue sélectionnée: ',
        langToastPrefix: 'Langue: '
    },
    es: {
        title: 'D20 Hoja de Personaje',
        tabCharacter: 'Personaje',
        tabSkills: 'Habilidades',
        tabSpells: 'Hechizos',
        tabInventory: 'Inventario',
        basicInfo: 'Información Básica',
        charName: 'Nombre del Personaje',
        charNamePlaceholder: 'Ingrese el nombre',
        charClass: 'Clase',
        charClassPlaceholder: 'Guerrero, mago, pícaro...',
        charRace: 'Raza',
        charRacePlaceholder: 'Humano, elfo, enano...',
        stats: 'Características',
        statStr: 'FUE',
        statDex: 'DES',
        statCon: 'CON',
        statInt: 'INT',
        statWis: 'SAB',
        statCha: 'CAR',
        health: 'Salud y Recursos',
        currentHP: 'PV Actuales',
        maxHP: 'PV Máximos',
        armorClass: 'Clase de Armadura',
        speed: 'Velocidad',
        notes: 'Notas',
        notesPlaceholder: 'Notas sobre el personaje, historia, características...',
        saveBtn: 'Guardar Personaje',
        loadBtn: 'Cargar Personaje',
        skills: 'Habilidades',
        skillName: 'Nombre de Habilidad',
        skillNamePlaceholder: 'Nueva habilidad',
        skillBonus: 'Bonificación',
        skillBonusPlaceholder: '+5 bonificación',
        addSkill: 'Añadir Habilidad',
        spells: 'Hechizos',
        spellName: 'Nombre del Hechizo',
        spellNamePlaceholder: 'Nuevo hechizo',
        spellLevel: 'Nivel',
        spellSlots: 'Espacios (total)',
        spellDesc: 'Descripción',
        spellDescPlaceholder: 'Efecto del hechizo',
        addSpell: 'Añadir Hechizo',
        inventory: 'Inventario',
        coinsPP: 'Platino',
        coinsGP: 'Oro',
        coinsSP: 'Plata',
        coinsCP: 'Cobre',
        totalValue: 'Valor Total',
        itemName: 'Nombre del Objeto',
        itemNamePlaceholder: 'Nuevo objeto',
        itemQuantity: 'Cantidad',
        itemPrice: 'Precio de Mercado',
        itemPricePlaceholder: 'varios oros',
        itemDesc: 'Descripción',
        itemDescPlaceholder: 'Propiedades del objeto',
        addItem: 'Añadir Objeto',
        noSkills: 'No hay habilidades añadidas',
        noSpells: 'No hay hechizos añadidos',
        noItems: 'Inventario vacío',
        savedMsg: '¡Personaje codificado y copiado al portapapeles!',
        loadedMsg: '¡Personaje cargado!',
        errorMsg: 'Error de decodificación. Verifique la cadena.',
        loadPrompt: 'Pegue los datos codificados del personaje:',
        // new keys
        modeReadLabel: 'Modo lectura',
        modeEditLabel: 'Modo edición',
        toastModeRead: 'Modo lectura',
        toastModeEdit: 'Modo edición',
        langSelectedPrefix: 'Idioma seleccionado: ',
        langToastPrefix: 'Idioma: '
    }
};

(function(){
    const repoProvidedTranslations = window.translations || {};
    const qs  = (sel)=>document.querySelector(sel);
    const qsa = (sel)=>Array.from(document.querySelectorAll(sel));
    
    // скрытый измеритель ширины текста
    const descMeasure = document.createElement('span');
    descMeasure.style.visibility = 'hidden';
    descMeasure.style.whiteSpace = 'pre';
    descMeasure.style.position = 'absolute';
    descMeasure.style.left = '-9999px';
    document.body.appendChild(descMeasure);

    function autosizeDescription(textarea){
        const style = getComputedStyle(textarea);
        descMeasure.style.font = style.font;
        descMeasure.textContent = textarea.value || textarea.placeholder || '';
        const contentWidth = descMeasure.offsetWidth + 10;
        textarea.style.width = contentWidth + 'px';
        textarea.style.height = 'auto';
        textarea.style.height = textarea.scrollHeight + 'px';
    }

    let character = {
        info: { name: '', race: '', class: '', level: 1 },
        stats: { Str: 10, Dex: 10, Con: 10, Int: 10, Wis: 10, Cha: 10 },
        hp: { current: 20, max: 20 },
        armorClass: 10,
        speed: 30,
        notes: '',
        skills: [],
        spells: [],
        inventory: [],
        coins: { pp:0, gp:0, sp:0, cp:0 }
    };

    const COIN_RATES = { pp:10, gp:1, sp:0.1, cp:0.01 };
    let currentLanguage = 'ru';
    const translationsObj = repoProvidedTranslations && Object.keys(repoProvidedTranslations).length
        ? repoProvidedTranslations
        : translations;

    // Tabs
    function initTabs(){
        qsa('.tab').forEach(btn => {
            btn.addEventListener('click', () => {
                const tab = btn.getAttribute('data-tab');
                switchTab(tab, btn);
            });
        });
    }
    function switchTab(tabName, btn){
        qsa('.tab').forEach(t=>t.classList.remove('active'));
        qsa('.tab-content').forEach(c=>c.classList.remove('active'));
        if (btn) btn.classList.add('active');
        const el = document.getElementById(tabName);
        if (el) el.classList.add('active');
    }

    // Stats
    function calcMod(score){
        const s = parseInt(score)||0;
        const m = Math.floor((s-10)/2);
        return (m>=0?'+':'')+m;
    }
    function updateStatModifiers(){
        ['Str','Dex','Con','Int','Wis','Cha'].forEach(k=>{
            const statEl = document.getElementById('stat'+k);
            const modEl  = document.getElementById('mod'+k);
            if (!statEl || !modEl) return;
            modEl.value = calcMod(statEl.value);
        });
    }

    // HP bar color
    function lerp(a, b, t){ return a + (b - a) * t; }
    function lerpColor(c1, c2, t){
        const r = Math.round(lerp(c1[0], c2[0], t));
        const g = Math.round(lerp(c1[1], c2[1], t));
        const b = Math.round(lerp(c1[2], c2[2], t));
        return `rgb(${r}, ${g}, ${b})`;
    }
    const HP_RED    = [0x8b, 0x2e, 0x1f];
    const HP_YELLOW = [0xc1, 0x9a, 0x3d];
    const HP_GREEN  = [0x4a, 0x7c, 0x4e];
    function getHpColorByPercent(ratio){
        const t = Math.max(0, Math.min(1, ratio));
        if (t <= 0.5){
            const localT = t / 0.5;
            return lerpColor(HP_RED, HP_YELLOW, localT);
        } else {
            const localT = (t - 0.5) / 0.5;
            return lerpColor(HP_YELLOW, HP_GREEN, localT);
        }
    }
    function updateHealthBar(){
        const cur = parseInt(qs('#currentHP').value) || 0;
        const max = Math.max(1, parseInt(qs('#maxHP').value) || 1);
        const bar = qs('#hpBar');
        const container = qs('#hpBarContainer');
        const thumb = qs('#hpThumb');
        if (!bar || !container || !thumb) return;
        const ratio = Math.max(0, Math.min(1, cur / max));
        bar.style.width = (ratio * 100) + '%';
        const color = getHpColorByPercent(ratio);
        bar.style.backgroundColor = color;
        // position thumb centered on the filled edge
        const contRect = container.getBoundingClientRect();
        const thumbW = Math.max(12, Math.min(40, Math.round(contRect.width * 0.06))); // responsive thumb width
        // thumb height = 120% of bar height (20% thicker)
        const thumbH = Math.round(contRect.height * 1.2);
        thumb.style.width = thumbW + 'px';
        thumb.style.height = thumbH + 'px';
        const left = Math.round(ratio * contRect.width - thumbW / 2);
        const clampedLeft = Math.max(0, Math.min(contRect.width - thumbW, left));
        thumb.style.left = clampedLeft + 'px';
        thumb.style.backgroundColor = color;
        thumb.setAttribute('aria-valuenow', Math.round(ratio * 100));
    }

    // Utility: restrict input to digits only (natural numbers)
    function restrictToDigitsInput(el){
      if (!el) return;
      el.addEventListener('input', ()=> {
        const before = el.value;
        // remove any non-digit characters
        const cleaned = (before || '').replace(/\D+/g, '');
        if (before !== cleaned) {
          const pos = (el.selectionStart || 0) - (before.length - cleaned.length);
          el.value = cleaned;
          try { el.setSelectionRange(pos, pos); } catch(e){}
        }
      });
      // prevent paste of non-digits
      el.addEventListener('paste', (ev)=>{
        ev.preventDefault();
        const text = (ev.clipboardData || window.clipboardData).getData('text') || '';
        const cleaned = text.replace(/\D+/g,'');
        const start = el.selectionStart || 0;
        const end = el.selectionEnd || 0;
        const newVal = el.value.slice(0,start) + cleaned + el.value.slice(end);
        el.value = newVal.replace(/\D+/g,'');
      });
    }

    // Utility: restrict input to bonus format: digits and + - variants
    function restrictToBonusInput(el){
      if (!el) return;
      const allowedRe = /[0-9+\-\u2013\u2014]/g; // digits and minus/dashes and plus
      el.addEventListener('input', ()=>{
        const before = el.value || '';
        const cleaned = (before.match(allowedRe) || []).join('');
        if (before !== cleaned) {
          const pos = (el.selectionStart || 0) - (before.length - cleaned.length);
          el.value = cleaned;
          try { el.setSelectionRange(pos, pos); } catch(e){}
        }
      });
      el.addEventListener('paste', (ev)=>{
        ev.preventDefault();
        const text = (ev.clipboardData || window.clipboardData).getData('text') || '';
        const cleaned = (text.match(allowedRe) || []).join('');
        const start = el.selectionStart || 0;
        const end = el.selectionEnd || 0;
        const newVal = el.value.slice(0,start) + cleaned + el.value.slice(end);
        el.value = (newVal.match(allowedRe) || []).join('');
      });
    }

    // Render lists (skills / spells / inventory)
    function renderSkills(){
        const container = qs('#skillsList'); container.innerHTML = '';
        if (!character.skills.length){
            const empty = document.createElement('div');
            empty.className = 'empty-state';
            empty.textContent = (translationsObj[currentLanguage] && translationsObj[currentLanguage].noSkills) || 'No skills added';
            container.appendChild(empty);
            return;
        }
        character.skills.forEach((s, idx)=>{
            const item = document.createElement('div'); item.className = 'item';
            const info = document.createElement('div'); info.className = 'item-info';
            const nameSpan = document.createElement('span'); nameSpan.textContent = s.name; nameSpan.className = 'item-name';
            const bonusInput = document.createElement('input'); bonusInput.type = 'text'; bonusInput.value = s.bonus || ''; bonusInput.className = 'item-details item-bonus compact-min';
            // allow + and - symbols also
            restrictToBonusInput(bonusInput);
            bonusInput.addEventListener('input', ()=>{ character.skills[idx].bonus = bonusInput.value; });
            info.appendChild(nameSpan); info.appendChild(bonusInput);
            const actions = document.createElement('div'); actions.className = 'item-actions';
            const del = document.createElement('button'); del.className = 'btn btn-small btn-danger btn-micro'; del.textContent = '×';
            del.addEventListener('click', ()=>{ character.skills.splice(idx,1); renderSkills(); });
            actions.appendChild(del); item.appendChild(info); item.appendChild(actions); container.appendChild(item);
        });
    }
    function onNewSkillNameInput(){ const name = qs('#newSkillName').value.trim(); qs('#skillsExtraFields').style.display = name ? 'block' : 'none'; }
    function addSkill(){ const name = qs('#newSkillName').value.trim(); if (!name) return; const bonus = qs('#newSkillBonus').value.trim(); character.skills.push({ name, bonus }); qs('#newSkillName').value = ''; qs('#newSkillBonus').value = ''; qs('#skillsExtraFields').style.display = 'none'; renderSkills(); }

    function renderSpells(){
        const container = qs('#spellsList'); container.innerHTML = '';
        if (!character.spells.length){
            const empty = document.createElement('div'); empty.className = 'empty-state';
            empty.textContent = (translationsObj[currentLanguage] && translationsObj[currentLanguage].noSpells) || 'No spells added';
            container.appendChild(empty); return;
        }
        const t = translationsObj[currentLanguage] || translationsObj['ru'] || {};
        const levelLabelText = t.spellLevel || 'Level';
        const slotsLabelText = t.spellSlots || 'Slots';
        character.spells.forEach((s, idx)=>{
            const item  = document.createElement('div'); item.className = 'item';
            const info  = document.createElement('div'); info.className = 'item-info';
            const name  = document.createElement('div'); name.className = 'item-name'; name.textContent = s.name;
            const details = document.createElement('div'); details.className = 'item-details';
            const metaLine = document.createElement('div');
            const lvlSpan = document.createElement('span'); lvlSpan.textContent = levelLabelText + ': ';
            const lvlInput = document.createElement('input'); lvlInput.type = 'text'; lvlInput.value = (s.level ?? 0).toString(); lvlInput.className = 'item-details compact-min'; lvlInput.style.width = '60px';
            // restrict to digits
            restrictToDigitsInput(lvlInput);
            lvlInput.addEventListener('input', ()=>{ const raw = lvlInput.value.trim(); const parsed = parseInt(raw, 10); character.spells[idx].level = Number.isNaN(parsed) ? 0 : parsed; });
            const sepSpan = document.createElement('span'); sepSpan.textContent = ' · ';
            const slotsSpan = document.createElement('span'); slotsSpan.textContent = slotsLabelText + ': ';
            const slotsInput = document.createElement('input'); slotsInput.type = 'text'; slotsInput.value = (s.slots ?? 0).toString(); slotsInput.className = 'item-details compact-min'; slotsInput.style.width = '60px';
            restrictToDigitsInput(slotsInput);
            slotsInput.addEventListener('input', ()=>{ const raw = slotsInput.value.trim(); const parsed = parseInt(raw, 10); character.spells[idx].slots = Number.isNaN(parsed) ? 0 : parsed; });
            metaLine.appendChild(lvlSpan); metaLine.appendChild(lvlInput); metaLine.appendChild(sepSpan); metaLine.appendChild(slotsSpan); metaLine.appendChild(slotsInput);
            const descArea = document.createElement('textarea'); descArea.value = s.desc || ''; descArea.rows  = 1; descArea.style.overflow = 'hidden'; descArea.style.resize   = 'none';
            const autoDesc = ()=> autosizeDescription(descArea);
            descArea.addEventListener('input', ()=>{ character.spells[idx].desc = descArea.value; autoDesc(); });
            setTimeout(autoDesc, 0);
            details.appendChild(metaLine); details.appendChild(descArea);
            info.appendChild(name); info.appendChild(details);
            const actions = document.createElement('div'); actions.className = 'item-actions';
            const del = document.createElement('button'); del.className = 'btn btn-small btn-danger btn-micro'; del.textContent = '×';
            del.addEventListener('click', ()=>{ character.spells.splice(idx,1); renderSpells(); });
            actions.appendChild(del); item.appendChild(info); item.appendChild(actions); container.appendChild(item);
        });
    }
    function onNewSpellNameInput(){ const name=qs('#newSpellName').value.trim(); qs('#spellsExtraFields').style.display = name ? 'block':'none'; }
    function addSpell(){ const name=qs('#newSpellName').value.trim(); if(!name) return; const level=parseInt(qs('#newSpellLevel').value)||0; const slots=parseInt(qs('#newSpellSlots').value)||0; const desc=qs('#newSpellDesc').value.trim(); character.spells.push({name,level,slots,desc}); qs('#newSpellName').value=''; qs('#newSpellDesc').value=''; qs('#newSpellLevel').value=''; qs('#newSpellSlots').value=''; qs('#spellsExtraFields').style.display='none'; renderSpells(); }

    function renderInventory(){
        const container = qs('#inventoryList'); container.innerHTML = '';
        if (!character.inventory.length){
            const empty = document.createElement('div'); empty.className = 'empty-state';
            empty.textContent = (translationsObj[currentLanguage] && translationsObj[currentLanguage].noItems) || 'Inventory is empty';
            container.appendChild(empty); return;
        }
        const t = translationsObj[currentLanguage] || translationsObj['ru'] || {};
        const qtyLabelText   = t.itemQuantity || 'Quantity';
        const priceLabelText = t.itemPrice   || 'Price';
        character.inventory.forEach((it, idx)=>{
            const item  = document.createElement('div'); item.className = 'item';
            const info  = document.createElement('div'); info.className = 'item-info';
            const name  = document.createElement('div'); name.className = 'item-name'; name.textContent = it.name;
            const details = document.createElement('div'); details.className = 'item-details';
            const qtyLine = document.createElement('div');
            const qtyLabelSpan = document.createElement('span'); qtyLabelSpan.textContent = qtyLabelText + ': ';
            const qtyInput = document.createElement('input'); qtyInput.type  = 'text'; qtyInput.value = (it.quantity ?? 1).toString(); qtyInput.className = 'item-details compact-min'; qtyInput.style.width = '70px';
            // restrict qty to digits
            restrictToDigitsInput(qtyInput);
            qtyInput.addEventListener('input', ()=>{ const raw = qtyInput.value.trim(); const parsed = parseInt(raw, 10); character.inventory[idx].quantity = Number.isNaN(parsed) ? 1 : parsed; updateInventoryTotal(); });
            qtyLine.appendChild(qtyLabelSpan); qtyLine.appendChild(qtyInput);
            const priceLine = document.createElement('div'); priceLine.textContent = priceLabelText + ': ' + (it.price || '');
            const descArea = document.createElement('textarea'); descArea.value = it.desc || ''; descArea.rows  = 1; descArea.style.overflow = 'hidden'; descArea.style.resize   = 'none';
            const autoItemDesc = ()=> autosizeDescription(descArea);
            descArea.addEventListener('input', ()=>{ character.inventory[idx].desc = descArea.value; autoItemDesc(); });
            setTimeout(autoItemDesc, 0);
            details.appendChild(qtyLine); details.appendChild(priceLine); details.appendChild(descArea);
            info.appendChild(name); info.appendChild(details);
            const actions = document.createElement('div'); actions.className = 'item-actions';
            const del = document.createElement('button'); del.className = 'btn btn-small btn-danger btn-micro'; del.textContent = '×';
            del.addEventListener('click', ()=>{ character.inventory.splice(idx,1); renderInventory(); updateInventoryTotal(); });
            actions.appendChild(del); item.appendChild(info); item.appendChild(actions); container.appendChild(item);
        });
    }
    function onNewItemNameInput(){ const name=qs('#ItemName').value.trim(); qs('#itemsExtraFields').style.display = name ? 'block':'none'; }
    function addItem(){ const name=qs('#ItemName').value.trim(); if(!name) return; const qty=parseInt(qs('#ItemQuantity').value)||1; const price=qs('#ItemPrice').value.trim(); const desc=qs('#ItemDesc').value.trim(); character.inventory.push({name,quantity:qty,price,desc}); qs('#ItemName').value=''; qs('#ItemQuantity').value=''; qs('#ItemPrice').value=''; qs('#ItemDesc').value=''; qs('#itemsExtraFields').style.display='none'; renderInventory(); updateInventoryTotal(); }

    function hasStem(word, stem, endings){ if (!word.includes(stem)) return false; return endings.some(end => word.endsWith(end)); }
    function parsePriceToGP(priceStr){
        if (!priceStr) return 0;
        const s = String(priceStr).toLowerCase();
        const numMatch = s.match(/([-+]?\d*\.?\d+)/);
        if (!numMatch) return 0;
        const val = parseFloat(numMatch[1]); if (isNaN(val)) return 0;
        const unitMap = [
            { unit: 'pp', match: str => ['pp','platinum','пм', 'пп'].some(k => str.includes(k)) || hasStem(str, 'платин', ['а','ы']) },
            { unit: 'gp', match: str => ['gp','gold','зм', 'гп'].some(k => str.includes(k)) || hasStem(str, 'золо', ['то','та','тых']) || hasStem(str, 'голд', ['','а','ы']) || hasStem(str, 'руб',  ['','ль','ля','лей']) },
            { unit: 'sp', match: str => ['sp','silver','см', 'сп'].some(k => str.includes(k)) || hasStem(str, 'серебр', ['о','а']) },
            { unit: 'cp', match: str => ['cp','copper','мм', 'кп'].some(k => str.includes(k)) || hasStem(str, 'мед',  ['ь','и','як','яка','яки','яков']) || hasStem(str, 'коп', ['','ейка','ейки','еек']) }
        ];
        let unit = 'gp';
        const found = unitMap.find(m => m.match(s));
        if (found) unit = found.unit;
        switch(unit){
            case 'pp': return val * COIN_RATES.pp;
            case 'sp': return val * COIN_RATES.sp;
            case 'cp': return val * COIN_RATES.cp;
            default:   return val;
        }
    }
    function updateInventoryTotal(){
        const pp=parseFloat(qs('#pp').value)||0; const gp=parseFloat(qs('#gp').value)||0; const sp=parseFloat(qs('#sp').value)||0; const cp=parseFloat(qs('#cp').value)||0;
        let total = pp*COIN_RATES.pp + gp*COIN_RATES.gp + sp*COIN_RATES.sp + cp*COIN_RATES.cp;
        character.inventory.forEach(it=>{ total += parsePriceToGP(it.price) * (it.quantity||1); });
        qs('#inventoryTotal').value = total.toFixed(2) + ' gp';
    }

    // Edit mode
    let isEditMode = true;
    function applyEditMode(){ const root = document.documentElement; if (isEditMode) root.classList.remove('readonly'); else root.classList.add('readonly'); }

    // i18n
    function initLanguage(){ setLanguage(currentLanguage); }
    function setLanguage(lang){
        if (!translationsObj[lang]) lang = 'ru';
        currentLanguage = lang;
        const toggle = qs('#langScrollToggle'); if (toggle) toggle.dataset.selected = lang;
        updateLanguage();
    }
    function updateLanguage(){
        const t = translationsObj[currentLanguage] || translationsObj['ru'] || {}; if (!t) return;
        const h1 = qs('h1'); if (h1) h1.textContent = t.title || 'D20 character sheet';
        const tabs = qsa('.tab'); if (tabs[0]) tabs[0].textContent = t.tabCharacter || 'Character'; if (tabs[1]) tabs[1].textContent = t.tabSkills || 'Skills'; if (tabs[2]) tabs[2].textContent = t.tabSpells || 'Spells'; if (tabs[3]) tabs[3].textContent = t.tabInventory || 'Inventory';
        const charH2 = qsa('#character .section h2'); if (charH2[0]) charH2[0].textContent = t.basicInfo || ''; if (charH2[1]) charH2[1].textContent = t.stats || ''; if (charH2[2]) charH2[2].textContent = t.health || ''; if (charH2[3]) charH2[3].textContent = t.notes || '';
        const skillsH2 = qs('#skills h2'); if (skillsH2) skillsH2.textContent = t.skills || 'Skills';
        const spellsH2 = qs('#spells h2'); if (spellsH2) spellsH2.textContent = t.spells || 'Spells';
        const invH2 = qs('#inventory h2'); if (invH2) invH2.textContent = t.inventory || 'Inventory';
        const setLabel = (sel, txt)=>{ const el = qs(sel); if (el) el.textContent = txt; };
        const setPh = (id, txt)=>{ const el = document.getElementById(id); if (el) el.placeholder = txt; };
        setLabel('label[for="charName"]', t.charName || 'Character Name'); setPh('charName', t.charNamePlaceholder || 'Enter name');
        setLabel('label[for="charRace"]', t.charRace || 'Race'); setPh('charRace', t.charRacePlaceholder || 'Human, elf...');
        setLabel('label[for="charClass"]', t.charClass || 'Class'); setPh('charClass', t.charClassPlaceholder || 'Warrior...');
        const statLabels = qsa('.stat-compact label'); if (statLabels[0]) statLabels[0].textContent = t.statStr || 'STR'; if (statLabels[1]) statLabels[1].textContent = t.statDex || 'DEX'; if (statLabels[2]) statLabels[2].textContent = t.statCon || 'CON'; if (statLabels[3]) statLabels[3].textContent = t.statInt || 'INT'; if (statLabels[4]) statLabels[4].textContent = t.statWis || 'WIS'; if (statLabels[5]) statLabels[5].textContent = t.statCha || 'CHA';
        setLabel('label[for="currentHP"]', t.currentHP || 'Current HP'); setLabel('label[for="maxHP"]', t.maxHP || 'Maximum HP'); setLabel('label[for="armorClass"]', t.armorClass || 'Armor Class'); setLabel('label[for="speed"]', t.speed || 'Speed'); setPh('notes', t.notesPlaceholder || 'Notes...');
        const saveBtn = qs('#saveBtn'); if (saveBtn) saveBtn.textContent = t.saveBtn || 'Save Character'; const loadBtn = qs('#loadBtn'); if (loadBtn) loadBtn.textContent = t.loadBtn || 'Load Character';
        setPh('newSkillName', t.skillNamePlaceholder || 'New skill'); setPh('newSkillBonus', t.skillBonusPlaceholder || '+0'); const addSkillBtn = qs('#addSkillBtn'); if (addSkillBtn) addSkillBtn.textContent = t.addSkill || 'Add Skill';
        setPh('newSpellName', t.spellNamePlaceholder || 'New spell'); setPh('newSpellDesc', t.spellDescPlaceholder || 'Spell effect'); const addSpellBtn = qs('#addSpellBtn'); if (addSpellBtn) addSpellBtn.textContent = t.addSpell || 'Add Spell';
        setPh('ItemName', t.itemNamePlaceholder || 'New item'); setPh('ItemPrice', t.itemPricePlaceholder || 'some gp'); setPh('ItemDesc', t.itemDescPlaceholder || 'Item properties'); const addItemBtn = qs('#addItemBtn'); if (addItemBtn) addItemBtn.textContent = t.addItem || 'Add Item';
        setLabel('label[for="pp"]', t.coinsPP || 'Platinum'); setLabel('label[for="gp"]', t.coinsGP || 'Gold'); setLabel('label[for="sp"]', t.coinsSP || 'Silver'); setLabel('label[for="cp"]', t.coinsCP || 'Copper'); setLabel('label[for="inventoryTotal"]', t.totalValue || 'Total Inventory Value');
        renderSkills(); renderSpells(); renderInventory(); updateInventoryTotal();
    }

    // persistence
    function encodeCharacter(){ const payload = Object.assign({}, character, { _meta:{ver:1} }); return btoa(unescape(encodeURIComponent(JSON.stringify(payload)))); }
    function decodeCharacter(str){ try{ const json = decodeURIComponent(escape(atob(str))); return JSON.parse(json); }catch(e){ return null; } }

    function saveCharacter(){
        character.info.name  = qs('#charName').value.trim();
        character.info.race  = qs('#charRace').value.trim();
        character.info.class = qs('#charClass').value.trim();
        ['Str','Dex','Con','Int','Wis','Cha'].forEach(k=>{ const el=document.getElementById('stat'+k); if(el) character.stats[k]=parseInt(el.value)||10; });
        character.hp.current = parseInt(qs('#currentHP').value)||0;
        character.hp.max     = parseInt(qs('#maxHP').value)||1;
        character.armorClass = parseInt(qs('#armorClass').value)||0;
        character.speed      = parseInt(qs('#speed').value)||0;
        character.notes      = qs('#notes').value || '';
        character.coins.pp = parseFloat(qs('#pp').value)||0; character.coins.gp = parseFloat(qs('#gp').value)||0; character.coins.sp = parseFloat(qs('#sp').value)||0; character.coins.cp = parseFloat(qs('#cp').value)||0;
        const encoded = encodeCharacter();
        try{ if (navigator.clipboard && navigator.clipboard.writeText) navigator.clipboard.writeText(encoded); }catch(e){}
        localStorage.setItem('d20_character', encoded);
        alert((translationsObj[currentLanguage] && translationsObj[currentLanguage].savedMsg) || 'Character encoded and copied to clipboard!');
    }

    function loadCharacter(){
        const stored = localStorage.getItem('d20_character'); let data = null; if (stored) data = decodeCharacter(stored);
        if (!data){
            const pasted = prompt((translationsObj[currentLanguage] && translationsObj[currentLanguage].loadPrompt) || 'Paste encoded character data:'); if (!pasted) return;
            data = decodeCharacter(pasted); if (!data){ alert((translationsObj[currentLanguage] && translationsObj[currentLanguage].errorMsg) || 'Decoding error. Check the string.'); return; }
        }
        try{
            if (data.info)  character.info  = Object.assign(character.info, data.info);
            if (data.stats) character.stats = Object.assign(character.stats, data.stats);
            if (data.hp)    character.hp    = Object.assign(character.hp, data.hp);
            if (data.coins) character.coins = Object.assign(character.coins, data.coins);
            character.skills    = Array.isArray(data.skills)?data.skills:character.skills;
            character.spells    = Array.isArray(data.spells)?data.spells:character.spells;
            character.inventory = Array.isArray(data.inventory)?data.inventory:character.inventory;
            character.armorClass = data.armorClass || character.armorClass;
            character.speed      = data.speed || character.speed;
            character.notes      = data.notes || character.notes;
            qs('#charName').value = character.info.name || '';
            qs('#charRace').value = character.info.race || '';
            qs('#charClass').value = character.info.class || '';
            ['Str','Dex','Con','Int','Wis','Cha'].forEach(k=>{ const el=document.getElementById('stat'+k); if(el) el.value = character.stats[k] || 10; });
            updateStatModifiers();
            qs('#currentHP').value = character.hp.current || 0; qs('#maxHP').value     = character.hp.max || 1; updateHealthBar();
            qs('#armorClass').value = character.armorClass || 0; qs('#speed').value      = character.speed || 0; qs('#notes').value      = character.notes || '';
            qs('#pp').value = character.coins.pp || 0; qs('#gp').value = character.coins.gp || 0; qs('#sp').value = character.coins.sp || 0; qs('#cp').value = character.coins.cp || 0;
            renderSkills(); renderSpells(); renderInventory(); updateInventoryTotal();
            alert((translationsObj[currentLanguage] && translationsObj[currentLanguage].loadedMsg) || 'Character loaded!');
        }catch(e){ alert((translationsObj[currentLanguage] && translationsObj[currentLanguage].errorMsg) || 'Decoding error. Check the string.'); }
    }

    // wire up handlers
    function wireUp(){
        qsa('.stat-value').forEach(inp=> inp.addEventListener('input', updateStatModifiers));
        const curHP = qs('#currentHP'); if (curHP) { restrictToDigitsInput(curHP); curHP.addEventListener('input', updateHealthBar); }
        const maxHP = qs('#maxHP'); if (maxHP) { restrictToDigitsInput(maxHP); maxHP.addEventListener('input', updateHealthBar); }
        const newSkillName = qs('#newSkillName'); if (newSkillName) newSkillName.addEventListener('input', onNewSkillNameInput);
        const addSkillBtn = qs('#addSkillBtn'); if (addSkillBtn) addSkillBtn.addEventListener('click', addSkill);
        const newSpellName = qs('#newSpellName'); if (newSpellName) newSpellName.addEventListener('input', onNewSpellNameInput);
        const addSpellBtn = qs('#addSpellBtn'); if (addSpellBtn) addSpellBtn.addEventListener('click', addSpell);
        const itemName = qs('#ItemName'); if (itemName) itemName.addEventListener('input', onNewItemNameInput);
        const addItemBtn = qs('#addItemBtn'); if (addItemBtn) addItemBtn.addEventListener('click', addItem);
        ['pp','gp','sp','cp'].forEach(id=>{ const el=qs('#'+id); if(el){ restrictToDigitsInput(el); el.addEventListener('input', updateInventoryTotal); } });
        // restrict add-form numeric fields to digits (note: ItemPrice intentionally NOT restricted)
        ['newSpellLevel','newSpellSlots','ItemQuantity','currentHP','maxHP','armorClass','speed'].forEach(id => {
            const el = qs('#' + id);
            if (!el) return;
            restrictToDigitsInput(el);
        });
        // bonus input: allow signs
        const bonusEl = qs('#newSkillBonus'); if (bonusEl) restrictToBonusInput(bonusEl);

        const saveBtn = qs('#saveBtn'); if (saveBtn) saveBtn.addEventListener('click', saveCharacter);
        const loadBtn = qs('#loadBtn'); if (loadBtn) loadBtn.addEventListener('click', loadCharacter);

        // initialize hp thumb drag/interaction
        initHpThumb();

        updateStatModifiers(); updateHealthBar(); renderSkills(); renderSpells(); renderInventory(); updateInventoryTotal();
    }

    initTabs(); initLanguage(); wireUp(); updateLanguage(); applyEditMode();

    // Ensure mode toggle circles have no stray text (keeps circles perfectly round)
    qsa('.mode-toggle .circle').forEach(c => { try { c.textContent = ''; } catch(e){} });

    // ---------- Unified toggles: tooltips, lens, center toast ----------
    function showCenterToast(text, ms = 1000) {
        const el = document.createElement('div'); el.className = 'center-toast'; el.textContent = text; document.body.appendChild(el);
        void el.offsetWidth; el.classList.add('show');
        setTimeout(()=>{ el.classList.remove('show'); setTimeout(()=>{ if (el && el.parentNode) el.parentNode.removeChild(el); },300); }, ms);
    }
    function createInlineTooltip(container, text) {
        let tip = container.querySelector('.inline-tooltip');
        if (!tip) { tip = document.createElement('div'); tip.className = 'inline-tooltip'; container.appendChild(tip); }
        tip.textContent = text; return tip;
    }
    function moveLensTo(toggleRoot, targetEl) {
        const lens = toggleRoot.querySelector('.lens'); if (!lens || !targetEl) return;
        const rootRect = toggleRoot.getBoundingClientRect(); const targetRect = targetEl.getBoundingClientRect();
        const centerX = (targetRect.left + targetRect.right) / 2 - rootRect.left; const centerY = (targetRect.top + targetRect.bottom) / 2 - rootRect.top;
        lens.style.left = (centerX - lens.offsetWidth / 2) + 'px'; lens.style.top  = (centerY - lens.offsetHeight / 2) + 'px';
    }

    // ---------- Mode toggle implementation (read/edit) ----------
    (function setupMode(){
      const root = qs('#modeToggle');
      if (!root) return;
      const circles = Array.from(root.querySelectorAll('.circle'));
      const lens = root.querySelector('.lens');
      circles.forEach(c => { try { c.textContent = ''; c.style.cursor = 'default'; } catch(e){} });

      // Move lens to a target circle
      function moveLens(target) {
        if (!lens || !target) return;
        const rootRect = root.getBoundingClientRect();
        const tRect = target.getBoundingClientRect();
        const cx = (tRect.left + tRect.right)/2 - rootRect.left;
        const cy = (tRect.top + tRect.bottom)/2 - rootRect.top;
        lens.style.left = (cx - lens.offsetWidth/2) + 'px';
        lens.style.top  = (cy - lens.offsetHeight/2) + 'px';
      }

      function setVisuals(mode){
        circles.forEach(c=>{
          const m = c.dataset.mode;
          if (m === mode) { c.classList.add('active'); c.classList.remove('inactive'); }
          else { c.classList.remove('active'); c.classList.add('inactive'); }
        });
        moveLens(root.querySelector('.circle.active') || circles[0]);
      }

      // show/hide add forms (#skillsAdd, #spellsAdd, #itemsAdd) depending on editable flag
      function updateAddFormsVisibility(editable){
        const ids = ['#skillsAdd','#spellsAdd','#itemsAdd'];
        ids.forEach(sel => {
          const el = qs(sel);
          if (!el) return;
          if (!editable) {
            if (typeof el.dataset._prevDisplay === 'undefined') el.dataset._prevDisplay = el.style.display || '';
            el.style.display = 'none';
            el.setAttribute('aria-hidden','true');
          } else {
            const prev = el.dataset._prevDisplay || '';
            el.style.display = prev || 'block';
            el.removeAttribute('aria-hidden');
          }
        });
      }

      // disable/enable content form controls (except top-right toggles and tabs)
      function setContentInteractivity(editable){
        // all inputs, textareas, selects and content buttons
        const all = Array.from(document.querySelectorAll('input, textarea, select, button'));
        all.forEach(el=>{
          // always skip the language and mode toggles and the tabs themselves
          if (el.closest('#modeToggle') || el.closest('#langScrollToggle') || el.closest('.top-right-controls') || el.closest('.tabs')) return;

          // KEEP currentHP interactive in read mode per user's request
          if (el.id === 'currentHP') return;

          // For buttons: only toggle buttons that belong to sections or are .btn (content buttons)
          if (el.tagName.toLowerCase() === 'button') {
            const isContentBtn = el.classList.contains('btn') || el.closest('.section') || el.closest('#skillsList') || el.closest('#inventoryList') || el.closest('#spellsList') || el.id === 'saveBtn' || el.id === 'loadBtn';
            if (!isContentBtn) return;
          }
          // store original disabled/readOnly/tabindex to restore accurately
          if (typeof el.dataset._origDisabled === 'undefined') el.dataset._origDisabled = el.disabled ? '1' : '0';
          if (typeof el.dataset._origReadonly === 'undefined') el.dataset._origReadonly = el.readOnly ? '1' : '0';
          if (typeof el.dataset._origTabindex === 'undefined') el.dataset._origTabindex = el.getAttribute('tabindex') || '';

          if (editable) {
            el.disabled = el.dataset._origDisabled === '1';
            try { el.readOnly = el.dataset._origReadonly === '1'; } catch(e){}
            if (el.dataset._origTabindex) el.setAttribute('tabindex', el.dataset._origTabindex);
            else el.removeAttribute('tabindex');
            el.style.pointerEvents = '';
          } else {
            el.disabled = true;
            try { el.readOnly = true; } catch(e){}
            el.setAttribute('tabindex', '-1');
            el.style.pointerEvents = 'none';
          }
        });

        // show/hide add forms also
        updateAddFormsVisibility(editable);
      }

      function setMode(mode, announce = true){
        mode = (mode === 'read') ? 'read' : 'edit';
        root.dataset.state = mode;
        setVisuals(mode);
        const editable = mode === 'edit';
        setContentInteractivity(editable);
        document.documentElement.classList.toggle('readonly', !editable);
        if (announce) {
          const t = translationsObj[currentLanguage] || translations['ru'];
          const msg = editable ? (t.toastModeEdit || 'Режим редактирования') : (t.toastModeRead || 'Режим чтения');
          try { showCenterToast(msg, 900); } catch(e) { /* ignore */ }
        }
        requestAnimationFrame(()=> moveLens(root.querySelector('.circle.active') || circles[0]));
      }

      // initial mode from dataset
      const init = root.dataset.state === 'read' ? 'read' : 'edit';
      setMode(init, false);

      root.addEventListener('click', (ev)=>{
        ev.preventDefault();
        const next = root.dataset.state === 'read' ? 'edit' : 'read';
        setMode(next, true);
      });

      // tooltip on hover showing localized mode string
      root.addEventListener('mouseenter', ()=> {
        const mode = root.dataset.state === 'read' ? 'read' : 'edit';
        const t = translationsObj[currentLanguage] || translations['ru'];
        const text = (mode === 'read') ? (t.modeReadLabel || 'Режим чтения') : (t.modeEditLabel || 'Режим редактирования');
        createInlineTooltip(root, text);
      });
      root.addEventListener('mouseleave', ()=> { const tt = root.querySelector('.inline-tooltip'); if (tt) tt.remove(); });

      root.addEventListener('keydown', (ev)=>{ if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); root.click(); } });
      window.addEventListener('resize', ()=> moveLens(root.querySelector('.circle.active') || circles[0]));
      // ensure lens placed correctly on load
      requestAnimationFrame(()=> moveLens(root.querySelector('.circle.active') || circles[0]));
      // expose setter for external calls
      root.setMode = setMode;
    })();

    // expose API
    window.d20 = Object.assign(window.d20 || {}, { character, setLanguage, saveCharacter, loadCharacter, addSkill, addSpell, addItem });

    // autosize notes
    const notes = document.getElementById('notes'); if (notes){ notes.style.overflow = 'hidden'; notes.style.resize = 'none'; const autoNotes = ()=> autosizeDescription(notes); notes.addEventListener('input', autoNotes); setTimeout(autoNotes, 0); }

    // ---------- HP thumb dragging and init ----------
    function initHpThumb(){
      const thumb = qs('#hpThumb');
      const container = qs('#hpBarContainer');
      const curInput = qs('#currentHP');
      const maxInput = qs('#maxHP');
      if (!thumb || !container || !curInput || !maxInput) return;

      function setFromClientX(clientX){
        const rect = container.getBoundingClientRect();
        const relative = clientX - rect.left;
        const ratio = Math.max(0, Math.min(1, relative / rect.width));
        const max = Math.max(1, parseInt(maxInput.value) || 1);
        const newVal = Math.round(ratio * max);
        curInput.value = String(newVal);
        updateHealthBar();
      }

      // pointer events (handles mouse & touch)
      let dragging = false;
      thumb.addEventListener('pointerdown', (ev)=>{
        ev.preventDefault();
        dragging = true;
        thumb.setPointerCapture(ev.pointerId);
        setFromClientX(ev.clientX);
      });
      window.addEventListener('pointermove', (ev)=>{
        if (!dragging) return;
        setFromClientX(ev.clientX);
      });
      window.addEventListener('pointerup', (ev)=>{
        if (!dragging) return;
        dragging = false;
        try { thumb.releasePointerCapture(ev.pointerId); } catch(e){}
      });

      // support keyboard left/right to change hp
      thumb.addEventListener('keydown', (ev)=>{
        const cur = Math.max(0, parseInt(qs('#currentHP').value)||0);
        const max = Math.max(1, parseInt(qs('#maxHP').value)||1);
        if (ev.key === 'ArrowLeft' || ev.key === 'ArrowDown') {
          ev.preventDefault();
          qs('#currentHP').value = String(Math.max(0, cur - 1));
          updateHealthBar();
        } else if (ev.key === 'ArrowRight' || ev.key === 'ArrowUp') {
          ev.preventDefault();
          qs('#currentHP').value = String(Math.min(max, cur + 1));
          updateHealthBar();
        } else if (ev.key === 'Home') {
          ev.preventDefault();
          qs('#currentHP').value = '0'; updateHealthBar();
        } else if (ev.key === 'End') {
          ev.preventDefault();
          qs('#currentHP').value = String(max); updateHealthBar();
        }
      });

      // update ARIA
      const observer = new MutationObserver(()=> {
        const cur = parseInt(curInput.value)||0;
        const max = Math.max(1, parseInt(maxInput.value)||1);
        thumb.setAttribute('aria-valuenow', Math.round((cur/max)*100));
      });
      observer.observe(curInput, { attributes: true, childList:false, characterData:false, subtree:false });
    }

    // ---------- Language scroll: replaced implementation (full behavior + animations) ----------
    (function setupLangScroll(){
      const root = qs('#langScrollToggle');
      if (!root) return;

      // mapping DOM text elements (positions):
      const domText = {
        1: qs('#langTextPosCenter'), // pos1 - center big circle (active)
        2: qs('#langTextPosRight'),  // pos2 - bottom-right
        3: qs('#langTextPosTop'),    // pos3 - top
        4: qs('#langTextPosLeft')    // pos4 - bottom-left
      };

      // mapping for element centers (we will use the text positions as anchor)
      function getCenter(el){
        const r = el.getBoundingClientRect();
        return { x: r.left + r.width/2, y: r.top + r.height/2 };
      }

      // initial order: pos1,pos2,pos3,pos4
      let order = ['ru','en','fr','es'];

      // if dataset.selected or currentLanguage present, rotate order so order[0] matches
      try {
        const desired = (typeof currentLanguage !== 'undefined' && currentLanguage) ? currentLanguage : root.dataset.selected || root.getAttribute('data-selected') || 'ru';
        while(order[0] !== desired) order = [ order[3], order[0], order[1], order[2] ];
      } catch (e){ /* ignore */ }

      const codeLabel = { ru:'RU', en:'EN', fr:'FR', es:'ES' };

      // localized full language names mapping by interface language (used for center toast)
      const languageNames = {
        ru: { ru:'русский', en:'English', fr:'russe', es:'ruso' },
        en: { ru:'английский', en:'English', fr:'anglais', es:'inglés' },
        fr: { ru:'французский', en:'French', fr:'français', es:'francés' },
        es: { ru:'испанский', en:'Spanish', fr:'espagnol', es:'español' }
      };

      // set initial classes (do not alter text styling beyond adding lang-text active/inactive)
      function renderStatic(){
        for(let i=1;i<=4;i++){
          const t = domText[i];
          if (!t) continue;
          const lang = order[i-1];
          t.textContent = codeLabel[lang] || (lang||'').toUpperCase();
          t.classList.add('lang-text');
          if (i === 1) {
            t.classList.add('active'); t.classList.remove('inactive');
          } else {
            t.classList.remove('active'); t.classList.add('inactive');
          }
        }
        root.dataset.selected = order[0];
      }

      // create floating clone text element (DOM) positioned at center x,y
      function createFloatingText(label, x, y, size = 14){
        const el = document.createElement('div');
        el.className = 'floating-clone';
        el.style.position = 'fixed';
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.transform = 'translate(-50%,-50%)';
        el.style.pointerEvents = 'none';
        el.style.zIndex = 9999;
        el.style.fontFamily = 'Palatino, Georgia, serif';
        el.style.fontWeight = '700';
        el.style.fontSize = size + 'px';
        el.style.color = getComputedStyle(document.body).color || '#000';
        el.style.transition = `transform 480ms cubic-bezier(.2,.9,.24,1), opacity 360ms ease`;
        el.textContent = label;
        document.body.appendChild(el);
        return el;
      }

      function createFloatingDot(x, y, d = 18){
        const el = document.createElement('div');
        el.className = 'floating-dot';
        el.style.position = 'fixed';
        el.style.left = (x - d/2) + 'px';
        el.style.top  = (y - d/2) + 'px';
        el.style.width = d + 'px';
        el.style.height = d + 'px';
        el.style.borderRadius = '50%';
        el.style.background = '#fff';
        el.style.boxShadow = '0 1px 3px rgba(0,0,0,0.2)';
        el.style.pointerEvents = 'none';
        el.style.zIndex = 9998;
        el.style.transition = `transform 480ms cubic-bezier(.2,.9,.24,1), opacity 360ms ease`;
        document.body.appendChild(el);
        return el;
      }

      let animating = false;

      function rotateOnce(){
        if (animating) return;
        animating = true;

        try {
          // capture current screen positions
          const p = {};
          for(let i=1;i<=4;i++){
            const el = domText[i];
            p[i] = getCenter(el);
          }

          // old labels
          const old = {1: order[0], 2: order[1], 3: order[2], 4: order[3]};

          // new order after rotation: newPos1 = oldPos4, newPos2 = oldPos1, newPos3 = oldPos2, newPos4 = oldPos3
          const newOrder = [ order[3], order[0], order[1], order[2] ];

          // create clones for outgoing (old pos1 -> pos2) and incoming (old pos4 -> pos1)
          const outLabel = createFloatingText(codeLabel[old[1]] || old[1].toUpperCase(), p[1].x, p[1].y, 16);
          const outDot   = createFloatingDot(p[1].x, p[1].y, 18);

          const inLabel  = createFloatingText(codeLabel[old[4]] || old[4].toUpperCase(), p[4].x, p[4].y, 12);
          const inDot    = createFloatingDot(p[4].x, p[4].y, 12);
          // initial styles for incoming: tiny & transparent
          inLabel.style.transform = 'translate(-50%,-50%) scale(.6)';
          inLabel.style.opacity = '0';
          inDot.style.transform = 'scale(.6)';
          inDot.style.opacity = '0';

          // fade static labels slightly to avoid duplicate visuals during animation
          for(let i=1;i<=4;i++){
            domText[i].style.transition = 'opacity 260ms ease';
            domText[i].style.opacity = '0.25';
          }

          // animate outgoing -> pos2 (shrink + fade)
          requestAnimationFrame(()=> {
            outLabel.style.transform = `translate(calc(-50% + ${p[2].x - p[1].x}px), calc(-50% + ${p[2].y - p[1].y}px)) scale(.5)`;
            outLabel.style.opacity = '0';
            outDot.style.transform = `translate(${p[2].x - p[1].x}px, ${p[2].y - p[1].y}px) scale(.45)`;
            outDot.style.opacity = '0';
          });

          // animate incoming -> pos1 (grow + appear) with small delay for overlap
          setTimeout(()=> {
            inLabel.style.transform = `translate(calc(-50% + ${p[1].x - p[4].x}px), calc(-50% + ${p[1].y - p[4].y}px)) scale(1.1)`;
            inLabel.style.opacity = '1';
            inDot.style.transform = `translate(${p[1].x - p[4].x}px, ${p[1].y - p[4].y}px) scale(1.15)`;
            inDot.style.opacity = '1';
          }, 40);

          // after animations finish, update static DOM texts and cleanup
          const cleanupAfter = 520;
          setTimeout(()=> {
            // remove clones
            try { outLabel.remove(); outDot.remove(); inLabel.remove(); inDot.remove(); } catch(e){}
            // update order and static labels
            order = newOrder.slice();
            for(let i=1;i<=4;i++){
              const t = domText[i];
              const lang = order[i-1];
              t.textContent = codeLabel[lang] || (lang||'').toUpperCase();
              // reset opacity and classes
              t.style.opacity = '';
              t.classList.remove('active','inactive','lang-shift-in','lang-shift-out');
              t.classList.add('lang-text');
              if (i===1) { t.classList.add('active'); t.classList.remove('inactive'); } else { t.classList.remove('active'); t.classList.add('inactive'); }
            }
            root.dataset.selected = order[0];
            // attempt to call setLanguage / updateLanguage if available
            const newLang = order[0];
            if (typeof setLanguage === 'function') {
              try { setLanguage(newLang); } catch(e){}
            } else if (window.d20 && typeof window.d20.setLanguage === 'function') {
              try { window.d20.setLanguage(newLang); } catch(e){}
            } else {
              try { window.currentLanguage = newLang; if (typeof updateLanguage === 'function') updateLanguage(); } catch(e){}
            }
            // show toast with full language name in interface language
            const iface = currentLanguage || 'ru';
            const namesForIface = languageNames[ newLang ] || languageNames['en'];
            const display = (namesForIface && namesForIface[iface]) ? namesForIface[iface] : (namesForIface && namesForIface['en']) || (newLang||'').toUpperCase();
            const toastPrefix = (translationsObj && translationsObj[currentLanguage] && translationsObj[currentLanguage].langToastPrefix) || 'Язык: ';
            showCenterToast(toastPrefix + display, 900);
            animating = false;
          }, cleanupAfter);
        } catch (err) {
          // on error ensure we reset state so button doesn't lock
          for(let i=1;i<=4;i++){
            if (domText[i]) { domText[i].style.opacity = ''; domText[i].classList.remove('inactive'); domText[i].classList.remove('active'); domText[i].classList.add('lang-text'); }
          }
          root.dataset.selected = order[0];
          animating = false;
          console.error('rotateOnce error:', err);
        }

        // safety fallback: ensure animating resets eventually
        setTimeout(()=> { animating = false; }, 1500);
      }

      // initialize rendering
      renderStatic();

      // handlers
      root.addEventListener('click', (ev)=> { ev.preventDefault(); rotateOnce(); });
      root.addEventListener('keydown', (ev)=> { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); rotateOnce(); } });

      // tooltip behavior: show short code like "Язык: RU"
      root.addEventListener('mouseenter', ()=> {
        const selected = root.dataset.selected || currentLanguage || 'ru';
        const prefix = (translationsObj && translationsObj[currentLanguage] && translationsObj[currentLanguage].langToastPrefix) || 'Язык: ';
        createInlineTooltip(root, prefix + (codeLabel[selected] || selected.toUpperCase()));
      });
      root.addEventListener('mouseleave', ()=> { const tt = root.querySelector('.inline-tooltip'); if (tt) tt.remove(); });

      // expose setter
      window.langScrollSet = function(langCode){
        const idx = order.indexOf(langCode);
        if (idx === -1) return;
        while(order[0] !== langCode) order = [ order[3], order[0], order[1], order[2] ];
        renderStatic();
      };
      window._langScrollState = { getOrder: () => order.slice() };
    })();

})();
    </script>
</body>
</html>
